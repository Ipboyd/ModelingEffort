% batch_extract_STRF_stats_JN
%
% This file goes through a directory of STRFs (one for each unit), looking
% for individual recording folders and determining the parameters for the
% optimal STRF for each unit.  Parameters obtained here are as follows:
%
% TolBest - the lowest tolerance for the STRFs obtained from all recordings
% for the given unit
% CCRBest, ConstCCBest - crosscorrelation ratio and constant
% crosscorrelation for the given STRF recording
% STRFJN_Cell - STRF estimated by using n-1 of the n stimuli used in
% stimulus presentation.  There are n total of these
% STRFJNstd_Cell - the standard deviation among the STRFJN_Cell
% STRF_Cell - mean value of the STRFJN_Cell
% tSliceGet - temporal slice at best frequency from t = 0 to t = 100 ms
% tPeak_JN - time location of the maximum value of the STRF
% Hpsd - Power spectral density (psd) structure generated by calling psd on
% tSliceGet
% BMF_JN - best modulation frequency of the temporal slice, obtained from
% the peak of the psd of tSliceGet
% CF_JN - center frequency, the frequency of the maximum peak in the STRF
% Q_JN - quality factor, a ratio between CF_JN and W, the width of the peak
% at half-maximum
% tiW_JN - temporal integration window, the width of the spectral peak at
% half-maximum 
% EIR_JN - excitatory-inhibitory ratio, the absolute value of the ratio
% between the peak excitatory and inhibitory points in the STRF
% SI_JN - separability index, obtained by performing singular value
% decomposition on the STRF, then taking the ratio of the first singular
% value to the sum of the first four SVs.
%
% These data are saved to a filename of the structure
% "bird_date_unit_STRFnumber.mat"

function batch_extract_STRF_stats_JN

defPath = pwd;

% Replace the following line with the directory where the STRFPAK output
% folders are located
prePath = 'D:\strf_folder_path\';

% This line indicates which folders you want to examine.  Separate each
% line with a semi-colon
inPaths = {
    'strf_folders';...
    };

nPath = length(inPaths);

% Designate a folder where you want the output stored.
preOutPath = 'D:\output_path\';

%try
for i=1:nPath
    cd(fullfile(prePath,inPaths{i},''));
    %% ~~ The line of code in between these sentences corresponds to a
    %% situation where I wanted to clump STRF analysis from the same unit
    %% together.  If you want to perform this analysis, make sure that each
    %% folder above contains 2+ STRF analysis folders, then uncomment the
    %% following lines ~~ %%
%     % We first search for the STRF directories in the current 'inPath'
%     d = dir;
%     subPath = {d.name}';
%     subPath = subPath(3:end); % This removes the '.' and '..' directories.
%     nSub = length(subPath);
%     tolOver = zeros(1,nSub);
% 
%     for p = 1:nSub
%     % For each STRF directory we load the best tolearance value
%         cd(fullfile(prePath,inPaths{i},subPath{p},''));
%         load info_r_result.mat;
%         load GlobalVariables;
%         [infoBest,infoDex]=max(cell2mat(infopre{1}));
%         tolOver(p) = Tol_val(infoDex);
%     end
%     
%     Tol_val = [0.1 0.05 0.01 0.005 0.001 0.0005 0.0001 0.00005];
%     % The tolerance value used is the maximum for all recordings from a
%     % particular unit
%     TolBest = max(tolOver);
%     infoDex = find(Tol_val == TolBest);
% 
%     for j = 1:nSub
%         cd(fullfile(prePath,inPaths{i},subPath{j},''));

    %% ~~ The line of code in between these sentences corresponds to a
    %% situation where I wanted to clump STRF analysis from the same unit
    %% together.  Uncomment if you want to do this as well ~~ %%

        load info_r_result.mat;
        load GlobalVariables;
        % The best tolerance corresponds to the max of 'infopre'
        %% NOTE: Comment out the lines below if using the multiple unit
        %% method
        subPath
        [infoBest,infoDex]=max(cell2mat(infopre{1}));
        infoDex = find(Tol_val == TolBest);
        TolBest = Tol_val(infoDex);
        %% NOTE: Comment out the lines above if using the multiple unit
        %% method
        CCRBest = cell2mat(cc_ratio_max{1}(infoDex));
        ConstCCBest = cell2mat(cc_spike_pre_constant{1}(infoDex))/...
            cell2mat(cc_two_halves_constant{1}(infoDex));
        strfFname = sprintf('strfResult_Tol%d.mat',infoDex);
        load(strfFname);
        
        % We're going to perform the calculations for the 20 jack-knife
        % estimates of the STRF.  I reported mean/std for the paper, so
        % it's preserved this way.  Remove the 'for' loop and call
        % STRF_Cell instead of STRFJN_Cell if you want use only the average
        % STRF

        for k = 1:size(STRFJN_Cell,3);
            STRF_now = squeeze(STRFJN_Cell(:,:,k));

            % ~~ Attain Frequency and Time Axes ~~
            Fs = 1000;
            start_freq=250;
            stop_freq=8000;
            [nx,nt]=size(STRF_Cell);
            maxforward = max(STRF_now(:));
            minforward = min(STRF_now(:));
            absforward = max(abs(minforward),abs(maxforward));
            faxis = linspace(start_freq, stop_freq, nx);
            t=-(nt-1)/2:(nt-1)/2;
            t0=(nt+1)/2;

            [fpeak,tpeak] = find(STRF_now==maxforward);

            % ~~ Calculation of CF, W, and Q ~~
            % ~ Slice taken @ peak time (along with standard deviation) ~
            fSlice = STRF_now(:,tpeak);
            CF_Hz = faxis(fpeak);
            CF_JN(k) = CF_Hz/1000;

            fSliceInterp = interp(fSlice,1000);
            [fSliceImax,fSliceIdex] = max(fSliceInterp);
            faxisInterp = linspace(start_freq, stop_freq, nx*1000);
            % Let's look for the points that are greater than half max;
            % this is the best way to do this since even 1000x
            % interpolation doesn't always fill in the gaps properly.
            greaterThanDex = find(fSliceInterp>=0.5*fSliceImax);
            % Now let's extract any resulting "peaks" that occur from the
            % extraction; ideally there would be only one, but that's not
            % always the case

            % First we use the diff function to weed out non-consecutive
            % indices of our greaterThanDex
            findNonCon = diff(greaterThanDex);
            % Non-consecutive peaks can be identified by finding out where
            % the difference is different from 1:
            breakDexes = find(findNonCon>1);
            if isempty(breakDexes) % The trivial case; one peak only!
                % nPeaks = 1;
                lowFdex = greaterThanDex(1);
                highFdex = greaterThanDex(end);
            else % It gets a bit more complicated here
                nPeaks = length(breakDexes) + 1;
                % greaterThanDex(breakDexes(1)), e.g., is the last index
                % number for group 1.
                % We're going to have to do this the 'hard' way, until I
                % can find a more automated way of doing this.
                groupDexes = [greaterThanDex(1) greaterThanDex(end)...
                    greaterThanDex(breakDexes)' greaterThanDex(breakDexes+1)'];
                groupDexes = sort(groupDexes);
                lowBound = groupDexes(find(fSliceIdex>groupDexes));
                if isempty(lowBound)
                    lowFdex = groupDexes(1);
                else
                    lowFdex = lowBound(end);
                end
                highBound = groupDexes(find(fSliceIdex<groupDexes));
                if isempty(highBound)
                    highFdex = groupDexes(end);
                else
                    highFdex = highBound(1);
                end
            end

            % fSliceMins = abs(fSliceImax*0.5 - fSliceInterp);
            % fSliceMins = fSliceMins - min(fSliceMins);
            %             plot(faxisInterp,fSliceInterp)
            %             figure
            %             plot(faxisInterp,fSliceMins)
            %                 % function maxima = findmaxima(x)
            % FINDMINIMA  Find location of local maxima
            %  From David Sampson
            % Identify whether signal is rising or falling
            % upordown = sign(diff(-fSliceMins));
            % Find points where signal is rising before, falling after
            % minflags = [upordown(1)<0; diff(upordown)<0; upordown(end)>0];
            % minima   = find(minflags);

            % Now separate the minima of the subtraction to find the low and
            % high frequencies for calculating W
            % lowFdex = minima(find(minima<fSliceIdex));
            % highFdex = minima(find(minima>fSliceIdex));
            % if fSliceIdex < minima(1)
            %     lowFdex = fSliceIdex;
            % elseif fSliceIdex > minima(end)
            %     highFdex = fSliceIdex;
            % end
            lowF = faxisInterp(lowFdex);
            highF = faxisInterp(highFdex);
            W_JN(k) = highF - lowF;

            %         W = new_X(3);
            Q_JN(k) = CF_Hz/W_JN(k);

            % ~~ Get Latency and Modulation Frequency ~~
            tSlice = STRF_now(fpeak,:);
            
            tPeak_JN(k) = t(tpeak);

            startT = find(t==0);
            endT = find(t==100);
            tSliceGet(k,:) = tSlice(startT:endT);

            Hamm = spectrum.welch;%('hann');
            Hamm.FFTLength = 'InputLength';
            Hpsd(k) = psd(Hamm,tSliceGet(k,:),'nfft',32768,'Fs',1000);
            [powmax,bmf_index]=max(Hpsd(k).Data);
            BMF_JN(k)=Hpsd(k).Frequencies(bmf_index);
            
            % ~~ Also get Temporal Integration Window ~~
            
            tSliceInterp = interp(tSliceGet(k,:),1000);
            [tSliceImax,tSliceIdex] = max(tSliceInterp);
            tAxisInterp = interp([0:1:100],1000);
            greaterThanDex = find(tSliceInterp>=0.5*tSliceImax);
            % Now let's extract any resulting "peaks" that occur from the
            % extraction; ideally there would be only one, but that's not
            % always the case

            % First we use the diff function to weed out non-consecutive
            % indices of our greaterThanDex
            findNonCon = diff(greaterThanDex);
            % Non-consecutive peaks can be identified by finding out where
            % the difference is different from 1:
            breakDexes = find(findNonCon>1);
            if isempty(breakDexes) % The trivial case; one peak only!
                % nPeaks = 1;
                lowTdex = greaterThanDex(1);
                highTdex = greaterThanDex(end);
            else % It gets a bit more complicated here
                nPeaks = length(breakDexes) + 1;
                % greaterThanDex(breakDexes(1)), e.g., is the last index
                % number for group 1.
                % We're going to have to do this the 'hard' way, until I
                % can find a more automated way of doing this.
                groupDexes = [greaterThanDex(1) greaterThanDex(end)...
                    greaterThanDex(breakDexes) greaterThanDex(breakDexes+1)];
                groupDexes = sort(groupDexes);
                lowBound = groupDexes(find(tSliceIdex>groupDexes));
                if isempty(lowBound)
                    lowTdex = groupDexes(1);
                else
                    lowTdex = lowBound(end);
                end
                highBound = groupDexes(find(tSliceIdex<groupDexes));
                if isempty(highBound)
                    highTdex = groupDexes(end);
                else
                    highTdex = highBound(1);
                end
            end

            lowT = tAxisInterp(lowTdex);
            highT = tAxisInterp(highTdex);
            tiW_JN(k) = highT - lowT;

            % ~~ E-I ratio ~~
            EIR_JN(k) = abs(maxforward/minforward);

            % ~~ Calculate SI ~~
            [cleanfilter,s,nsig,SI_JN(k)] = gen_xSVDfilter_STRF(STRF_now);
        end

%         info = strread(subPath{j},'%s','delimiter','_');
% 
%         if size(info,1) == 5
%             part3 = [char(info{4}),'_',char(info{5})];
%         else
%             part3 = char(info{4});
%         end

        % outFile = [char(info{1}),'_',char(info{3}),'_',part3,'.mat'];
        if exist(subPath{j})
            outFile = [subPath{j},'.mat'];
            outPath = [preOutPath,'\',inPaths{i}];
            if ~exist(outPath,'dir')
                mkdir(outPath);
            end
        else
            outFile = [inPaths{i},'.mat'];
            outPath = preOutPath;
        end
        save(fullfile(outPath,outFile),'TolBest','CCRBest','ConstCCBest',...
            'STRFJN_Cell','STRFJNstd_Cell','STRF_Cell','tSliceGet','Hpsd','tPeak_JN',...
            'BMF_JN','CF_JN','Q_JN','tiW_JN','EIR_JN','SI_JN');
    %% ~~ Uncomment this 'end' to use the multiple recordings algorithm as
    %% explained above ~~ %%
%     end
    %% ~~ %%
end

% catch
%     pwd
%     cd(defPath);
%     rethrow(lasterror);
% end